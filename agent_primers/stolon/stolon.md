# Stolon - HTTP API Access Layer

## Overview

Stolon is the HTTP API access layer that complements Rhizome's database access layer. While both are part of the Trifolium project and share similar architectural principles, they serve different purposes:

- **Rhizome**: Provides access to Clover's databases (MySQL, CloudSQL)
- **Stolon**: Provides access to Clover's HTTP APIs and services

The biological metaphor continues:
- **Rhizomes** grow underground (database connections through port-forwarding and tunnels)
- **Stolons** grow aboveground (HTTP connections through public or internal APIs)

## Key Differences from Rhizome

### 1. Connection Type
- **Rhizome**: SQL connections via port-forwarding, kubectl, CloudSQL proxy
- **Stolon**: HTTP/REST connections via authenticated API endpoints

### 2. Authentication
- **Rhizome**: Database credentials from 1Password/Pybritive, SQL authentication
- **Stolon**: Internal session tokens captured via browser, managed by stolon server

### 3. Data Format
- **Rhizome**: Tabular data with SQLModel ORM, structured schemas
- **Stolon**: JSON responses from OpenAPI-defined endpoints with generated type-safe clients

### 4. Infrastructure Requirements
- **Rhizome**: Kubernetes access, port-forwarding, VPN for production databases
- **Stolon**: API endpoints (may be public or require authentication), stolon server for token management

## Stolon Architecture

Stolon uses a **server-client architecture** with **generated API clients** that automatically proxy all requests through the stolon server.

### Server Component (`stolon serve`)

The Stolon server (port 8001 by default) handles:

1. **Authentication Management**
   - Internal session token capture and caching
   - Automatic token refresh on 401 responses
   - Token-per-domain management

2. **Request Proxying**
   - All HTTP requests flow through the server via `StolonClient.proxy_request()`
   - Server adds authentication headers/cookies automatically
   - Handles request/response logging for visibility

3. **Token Capture Server (port 49152)**
   - Dedicated server for capturing tokens from browser
   - Browser extension integration for automatic token extraction
   - Manual fallback UI for token entry

### Generated API Clients

Stolon generates two layers of API clients:

#### Layer 1: OpenAPI Generated Clients (`stolon.openapi_generated`)

Raw clients generated by `openapi-python-client` from live service specs:

```bash
# Fetch spec and generate client
stolon sync spec --env dev --service billing-bookkeeper

# Generated at: src/stolon/openapi_generated/billing_bookkeeper_dev/
```

**Contents**:
- Type-safe models for all request/response schemas
- API functions that match the OpenAPI spec exactly
- Authentication stubs (not functional without modification)

**Do not use directly** - these clients don't include authentication or proxying.

#### Layer 2: Proxied Wrappers (`stolon.generated`)

Wrapper functions that proxy through stolon server for transparent authentication:

```bash
# Generated automatically by stolon sync spec
# OR regenerate just wrappers without fetching specs:
stolon sync wrappers --env dev --service billing-bookkeeper

# Generated at: src/stolon/generated/billing_bookkeeper_dev/
```

**Contents**:
- Wrapper functions for each OpenAPI endpoint
- Automatic proxying through stolon server via `StolonClient.proxy_request()`
- Same signatures as OpenAPI clients but with `client: StolonClient` parameter
- Sync and async variants for each endpoint

**Example wrapper**:
```python
def create_billing_entity_sync_detailed(
    *, client: StolonClient, body: ApiBillingEntity
) -> Response[ApiBillingEntity]:
    """Create a billing entity (automatically proxied through stolon server)."""

    # Extract request parameters from generated function
    kwargs = create_billing_entity._get_kwargs(body=body)

    # Proxy request through stolon server (handles auth automatically)
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_data=kwargs.get("json"),
        headers=kwargs.get("headers"),
    )

    # Parse response using generated client's parser
    return Response(
        status_code=proxy_response.status_code,
        content=proxy_response.body.encode(),
        headers=proxy_response.headers,
        parsed=parse_response(proxy_response),
    )
```

### Client Component

The `StolonClient` provides the interface to the stolon server:

```python
from stolon.client import StolonClient

client = StolonClient()

# Proxy request through stolon server
response = client.proxy_request(
    domain="dev1.dev.clover.com",
    method="POST",
    path="/v3/billing_entities",
    environment_name="dev",
    json_data={"entityUuid": "...", "name": "..."},
)
```

**Key Features**:
- Automatic token retrieval/refresh
- Request/response logging
- Centralized authentication handling
- No manual token management needed

## Workflow: Adding a New API Service

### Step 1: Generate OpenAPI Client and Wrappers

```bash
# Fetch OpenAPI spec from live service and generate both layers
stolon sync spec --env dev --service billing-bookkeeper

# This creates:
# - src/stolon/openapi_generated/billing_bookkeeper_dev/ (raw OpenAPI client)
# - src/stolon/generated/billing_bookkeeper_dev/ (proxied wrappers)
```

### Step 2: Regenerate Wrappers (If Needed)

After fixing wrapper generator or updating wrapper patterns:

```bash
# Regenerate just the wrappers without fetching specs
stolon sync wrappers --env dev --service billing-bookkeeper

# This updates:
# - src/stolon/generated/billing_bookkeeper_dev/ (proxied wrappers)
```

### Step 3: Create Environment Wrapper Class

Create a high-level API class in `trifolium.environments` that uses the generated wrappers:

```python
# src/trifolium/environments/dev.py

from stolon.environments import base
from stolon.generated.billing_bookkeeper_dev.billing_entity import (
    create_billing_entity_sync_detailed,
)
from stolon.openapi_generated.billing_bookkeeper_dev.open_api_definition_client.models import (
    api_billing_entity,
)

class DevBillingBookkeeperAPI(base.Environment):
    """Billing Bookkeeper API wrapper using proxied wrapper functions.

    This class uses the generated wrapper functions that automatically proxy
    all requests through the stolon server, which handles authentication,
    token management, and logging.
    """

    @property
    def name(self) -> str:
        return "dev"

    @property
    def domain(self) -> str:
        return "dev1.dev.clover.com"

    def create_entity(self, entity_uuid: str, entity_type: str, name: str) -> dict[str, Any]:
        """Create a billing entity."""
        # Create model from generated OpenAPI types
        entity_model = api_billing_entity.ApiBillingEntity(
            entity_uuid=entity_uuid,
            entity_type=api_billing_entity_entity_type.ApiBillingEntityEntityType(entity_type),
            name=name,
        )

        # Call proxied wrapper (automatically handles auth via stolon server)
        response = create_billing_entity_sync_detailed(
            client=self.client,  # StolonClient from base.Environment
            body=entity_model,
        )

        if response.status_code != 200:
            raise Exception(f"Failed to create entity: {response.status_code}")

        return response.parsed.to_dict()
```

### Step 4: Usage in Tests or Scripts

```python
from trifolium.environments import dev
from stolon.client import StolonClient

# Create environment with stolon client
environment = dev.Environment(
    rhizome_client=RhizomeClient(),
    stolon_client=StolonClient()
)

# Use high-level API (auth handled automatically)
entity = environment.api.billing_bookkeeper.create_entity(
    entity_uuid="ABC1234567890",
    entity_type="MERCHANT",
    name="Test Merchant"
)
```

## How Stolon Server Works

### Startup Flow

1. **Start Server**:
   ```bash
   stolon serve [--port 8001]
   ```

2. **Server Ready**:
   - Main server listening on port 8001
   - Token capture server ready on port 49152
   - Token cache initialized (empty)

### Request Flow

1. **Client Makes Request**:
   ```python
   response = client.proxy_request(
       domain="dev1.dev.clover.com",
       method="POST",
       path="/v3/resellers",
       environment_name="dev",
       json_data={...}
   )
   ```

2. **Server Processing**:
   - Check token cache for domain
   - If no token: trigger token capture flow (browser opens)
   - If token exists: use cached token
   - Add authentication headers (`Cookie: internalSession=<token>`)
   - Forward request to actual API
   - Log request/response for visibility

3. **Token Expiration Handling**:
   - If API returns 401: invalidate cached token
   - Trigger new token capture
   - Retry request with fresh token
   - All handled transparently

## Two Approaches to API Access

Stolon supports two patterns depending on whether OpenAPI specs are available:

### Approach 1: Generated Wrappers (Preferred)

For services with OpenAPI specs (billing-bookkeeper, agreement-k8s, billing-event):

```python
# Use generated wrapper - automatic proxying
from stolon.generated.billing_bookkeeper_dev.billing_entity import (
    create_billing_entity_sync_detailed,
)

response = create_billing_entity_sync_detailed(
    client=stolon_client,
    body=entity_model,
)
```

**Benefits**:
- Type-safe request/response models
- IDE autocomplete for all parameters
- Automatic serialization/deserialization
- Compile-time validation

### Approach 2: Direct HTTP Methods

For services without OpenAPI specs or custom endpoints:

```python
# Direct HTTP via base.Environment methods
class DevResellersAPI(base.Environment):
    @property
    def name(self) -> str:
        return "dev"

    @property
    def domain(self) -> str:
        return "dev1.dev.clover.com"

    def create_reseller(self, name: str, owner_email: str, ...) -> dict[str, Any]:
        # Use inherited post() method from base.Environment
        response = self.post("/v3/resellers", json={
            "name": name,
            "owner": {"email": owner_email},
            ...
        })
        return response
```

**Benefits**:
- Works without OpenAPI specs
- Simple for one-off endpoints
- Still gets auth and logging from base.Environment

## Authentication Flow Details

### Token Capture with Browser Extension

1. **User runs**: `stolon internal-token dev1.dev.clover.com`
2. **Server starts**: Token capture server on port 49152
3. **Browser opens**: `https://dev1.dev.clover.com/admin`
4. **User logs in**: Normal authentication flow
5. **Extension detects**: Clover Session Extension sees stolon waiting
6. **Token extracted**: Extension reads `internalSession` cookie
7. **Token sent**: Extension POSTs token to `localhost:49152/auth/submit`
8. **Server caches**: Token stored for domain
9. **Ready**: Future requests use cached token

### Manual Token Capture Fallback

If browser extension not installed:

1. **UI opens**: `http://localhost:49152` (manual entry form)
2. **User logs in**: Opens admin page in separate tab
3. **Manual extraction**: Copy `internalSession` cookie from DevTools
4. **Submit**: Paste token into form
5. **Server caches**: Token stored for domain

## Integration with Rhizome

Stolon and Rhizome work together for complete data access:

```python
from rhizome.client import RhizomeClient
from rhizome.environments import DevBillingBookkeeper
from stolon.client import StolonClient
from trifolium.environments import dev

# Create unified environment
environment = dev.Environment(
    rhizome_client=RhizomeClient(),
    stolon_client=StolonClient()
)

# Query database via Rhizome
entity = environment.db.billing_bookkeeper.select_first(
    select(BillingEntity).where(BillingEntity.entity_uuid == "ABC123")
)

# Create via API using Stolon
new_entity = environment.api.billing_bookkeeper.create_entity(
    entity_uuid="XYZ789",
    entity_type="MERCHANT",
    name="Test Merchant"
)

# Verify creation via database
created_entity = environment.db.billing_bookkeeper.select_first(
    select(BillingEntity).where(BillingEntity.entity_uuid == "XYZ789")
)
```

## Benefits of Stolon

### 1. Zero Manual Token Management
- Tokens captured once, reused automatically
- Automatic refresh on expiration
- No manual cookie extraction needed

### 2. Type Safety with Generated Clients
- OpenAPI specs → type-safe Python models
- IDE autocomplete for all API parameters
- Compile-time validation of requests

### 3. Transparent Request Proxying
- All requests flow through stolon server
- Authentication added automatically
- Logging for all HTTP traffic

### 4. Tribal Knowledge Capture
- API quirks documented in environment classes
- Authentication patterns centralized
- Environment differences captured in code

### 5. Testing and Development Efficiency
- Easy mocking for unit tests
- Consistent interface across environments
- No manual auth setup in tests

## Directory Structure

```
src/stolon/
├── openapi_generated/          # Raw OpenAPI clients (DO NOT USE DIRECTLY)
│   ├── billing_bookkeeper_dev/
│   ├── agreement_k8s_dev/
│   └── billing_event_dev/
├── generated/                   # Proxied wrappers (USE THESE)
│   ├── billing_bookkeeper_dev/
│   │   ├── billing_entity.py   # Wrapper functions for billing entities
│   │   ├── alliance_code.py    # Wrapper functions for alliance codes
│   │   └── ...
│   └── agreement_k8s_dev/
├── environments/
│   └── base.py                  # Base environment class with auth/logging
├── client.py                    # StolonClient for proxying requests
├── server.py                    # Stolon server (port 8001)
├── cli.py                       # CLI commands (serve, internal-token, sync)
├── sync_spec.py                 # OpenAPI client and wrapper generation
└── generate_wrappers.py         # Wrapper generation logic

src/trifolium/environments/
├── dev.py                       # Dev environment with unified DB + API access
├── demo.py                      # Demo environment (TBD)
└── prod.py                      # Prod environment (TBD)
```

## Commands Reference

### Server Management

```bash
# Start stolon server
stolon serve [--port 8001]

# Server provides:
# - Request proxying on port 8001
# - Token capture on port 49152
```

### Token Management

```bash
# Capture token for a domain (interactive)
stolon internal-token dev1.dev.clover.com

# Clear cached token for a domain
stolon clear-cache dev1.dev.clover.com
```

### Client Generation

```bash
# Fetch OpenAPI spec and generate client + wrappers
stolon sync spec --env dev --service billing-bookkeeper [--overwrite]

# Regenerate wrappers only (no spec fetch)
stolon sync wrappers --env dev --service billing-bookkeeper

# Service aliases
stolon sync spec --env dev --service agreement  # Expands to agreement-k8s
```

## Summary

Stolon extends the Trifolium philosophy to HTTP APIs:
- **Rhizome** handles underground connections (databases)
- **Stolon** handles aboveground connections (APIs)

Together, they provide a complete data access layer that:
- Captures institutional knowledge in code
- Provides type safety via generated clients
- Simplifies authentication with transparent proxying
- Enables progressive environment migrations
- Centralizes request logging and monitoring

The key innovation is the **dual-layer client generation**:
1. **OpenAPI layer**: Type-safe models and API functions from specs
2. **Wrapper layer**: Proxying through stolon server for automatic authentication

This allows developers to use type-safe, authenticated API clients without manual token management.
