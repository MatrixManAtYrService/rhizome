"""
Proxied wrapper functions for billing-bookkeeper dev - alliance_code.

Auto-generated by stolon sync spec.
These wrappers route requests through the stolon server for automatic
token management, logging, and retry logic.
"""

from http import HTTPStatus
from stolon.client import StolonClient
from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.api.alliance_code import create_invoice_alliance_code
from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.api.alliance_code import get_invoice_alliance_code_by_uuid
from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.api.alliance_code import get_invoice_alliance_codes
from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.api.alliance_code import resolve_invoice_alliance_code
from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.models.response_error import ResponseError
from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.types import Response
from typing import Any
import json


def create_invoice_alliance_code_sync_detailed(
    *,
    client: StolonClient
) -> Response[ResponseError]:
    """Create invoice alliance codes

    Args:
        body (ApiInvoiceAllianceCode):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[ResponseError]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
        

    Returns:
        Response[ResponseError]
    """
    # Extract request parameters from generated function
    kwargs = create_invoice_alliance_code._get_kwargs()

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    import json
    from http import HTTPStatus
    from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        try:
            body_json = json.loads(proxy_response.body)
        except json.JSONDecodeError:
            pass

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and ResponseError:
        parsed = ResponseError.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode('utf-8') if proxy_response.body else b'',
        headers=proxy_response.headers,
        parsed=parsed,
    )




def create_invoice_alliance_code_sync(
    *,
    client: StolonClient
) -> ResponseError | None:
    """Create invoice alliance codes

    Args:
        body (ApiInvoiceAllianceCode):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        ResponseError

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
        

    Returns:
        ResponseError | None
    """
    # Extract request parameters from generated function
    kwargs = create_invoice_alliance_code._get_kwargs()

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body
    import json
    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return ResponseError.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None




def create_invoice_alliance_code_asyncio_detailed(
    *,
    client: StolonClient
) -> Response[ResponseError]:
    """Create invoice alliance codes

    Args:
        body (ApiInvoiceAllianceCode):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[ResponseError]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
        

    Returns:
        Response[ResponseError]
    """
    # Extract request parameters from generated function
    kwargs = create_invoice_alliance_code._get_kwargs()

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    import json
    from http import HTTPStatus
    from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        try:
            body_json = json.loads(proxy_response.body)
        except json.JSONDecodeError:
            pass

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and ResponseError:
        parsed = ResponseError.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode('utf-8') if proxy_response.body else b'',
        headers=proxy_response.headers,
        parsed=parsed,
    )




def create_invoice_alliance_code_asyncio(
    *,
    client: StolonClient
) -> ResponseError | None:
    """Create invoice alliance codes

    Args:
        body (ApiInvoiceAllianceCode):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        ResponseError

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
        

    Returns:
        ResponseError | None
    """
    # Extract request parameters from generated function
    kwargs = create_invoice_alliance_code._get_kwargs()

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body
    import json
    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return ResponseError.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None




def get_invoice_alliance_code_by_uuid_sync_detailed(
    *,
    client: StolonClient,
    uuid: str
) -> Response[ResponseError]:
    """Get invoice alliance code definition by UUID

    Args:
        uuid (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[ResponseError]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                uuid: str

    Returns:
        Response[ResponseError]
    """
    # Extract request parameters from generated function
    kwargs = get_invoice_alliance_code_by_uuid._get_kwargs(uuid=uuid)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    import json
    from http import HTTPStatus
    from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        try:
            body_json = json.loads(proxy_response.body)
        except json.JSONDecodeError:
            pass

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and ResponseError:
        parsed = ResponseError.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode('utf-8') if proxy_response.body else b'',
        headers=proxy_response.headers,
        parsed=parsed,
    )




def get_invoice_alliance_code_by_uuid_sync(
    *,
    client: StolonClient,
    uuid: str
) -> ResponseError | None:
    """Get invoice alliance code definition by UUID

    Args:
        uuid (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        ResponseError

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                uuid: str

    Returns:
        ResponseError | None
    """
    # Extract request parameters from generated function
    kwargs = get_invoice_alliance_code_by_uuid._get_kwargs(uuid=uuid)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body
    import json
    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return ResponseError.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None




def get_invoice_alliance_code_by_uuid_asyncio_detailed(
    *,
    client: StolonClient,
    uuid: str
) -> Response[ResponseError]:
    """Get invoice alliance code definition by UUID

    Args:
        uuid (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[ResponseError]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                uuid: str

    Returns:
        Response[ResponseError]
    """
    # Extract request parameters from generated function
    kwargs = get_invoice_alliance_code_by_uuid._get_kwargs(uuid=uuid)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    import json
    from http import HTTPStatus
    from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        try:
            body_json = json.loads(proxy_response.body)
        except json.JSONDecodeError:
            pass

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and ResponseError:
        parsed = ResponseError.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode('utf-8') if proxy_response.body else b'',
        headers=proxy_response.headers,
        parsed=parsed,
    )




def get_invoice_alliance_code_by_uuid_asyncio(
    *,
    client: StolonClient,
    uuid: str
) -> ResponseError | None:
    """Get invoice alliance code definition by UUID

    Args:
        uuid (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        ResponseError

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                uuid: str

    Returns:
        ResponseError | None
    """
    # Extract request parameters from generated function
    kwargs = get_invoice_alliance_code_by_uuid._get_kwargs(uuid=uuid)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body
    import json
    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return ResponseError.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None




def get_invoice_alliance_codes_sync_detailed(
    *,
    client: StolonClient
) -> Response[ResponseError]:
    """Get invoice alliance codes

    Args:
        billing_entity_uuid (Union[Unset, str]):
        alliance_code (Union[Unset, str]):
        page_size (Union[Unset, int]):
        page_number (Union[Unset, int]):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[ResponseError]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
        

    Returns:
        Response[ResponseError]
    """
    # Extract request parameters from generated function
    kwargs = get_invoice_alliance_codes._get_kwargs()

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    import json
    from http import HTTPStatus
    from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        try:
            body_json = json.loads(proxy_response.body)
        except json.JSONDecodeError:
            pass

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and ResponseError:
        parsed = ResponseError.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode('utf-8') if proxy_response.body else b'',
        headers=proxy_response.headers,
        parsed=parsed,
    )




def get_invoice_alliance_codes_sync(
    *,
    client: StolonClient
) -> ResponseError | None:
    """Get invoice alliance codes

    Args:
        billing_entity_uuid (Union[Unset, str]):
        alliance_code (Union[Unset, str]):
        page_size (Union[Unset, int]):
        page_number (Union[Unset, int]):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        ResponseError

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
        

    Returns:
        ResponseError | None
    """
    # Extract request parameters from generated function
    kwargs = get_invoice_alliance_codes._get_kwargs()

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body
    import json
    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return ResponseError.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None




def get_invoice_alliance_codes_asyncio_detailed(
    *,
    client: StolonClient
) -> Response[ResponseError]:
    """Get invoice alliance codes

    Args:
        billing_entity_uuid (Union[Unset, str]):
        alliance_code (Union[Unset, str]):
        page_size (Union[Unset, int]):
        page_number (Union[Unset, int]):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[ResponseError]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
        

    Returns:
        Response[ResponseError]
    """
    # Extract request parameters from generated function
    kwargs = get_invoice_alliance_codes._get_kwargs()

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    import json
    from http import HTTPStatus
    from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        try:
            body_json = json.loads(proxy_response.body)
        except json.JSONDecodeError:
            pass

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and ResponseError:
        parsed = ResponseError.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode('utf-8') if proxy_response.body else b'',
        headers=proxy_response.headers,
        parsed=parsed,
    )




def get_invoice_alliance_codes_asyncio(
    *,
    client: StolonClient
) -> ResponseError | None:
    """Get invoice alliance codes

    Args:
        billing_entity_uuid (Union[Unset, str]):
        alliance_code (Union[Unset, str]):
        page_size (Union[Unset, int]):
        page_number (Union[Unset, int]):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        ResponseError

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
        

    Returns:
        ResponseError | None
    """
    # Extract request parameters from generated function
    kwargs = get_invoice_alliance_codes._get_kwargs()

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body
    import json
    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return ResponseError.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None




def resolve_invoice_alliance_code_sync_detailed(
    *,
    client: StolonClient,
    billing_entity_uuid: str
) -> Response[ResponseError]:
    """Resolve the invoice alliance code definition that applies for the specified billing entity

    Args:
        billing_entity_uuid (str):
        date (Union[Unset, datetime.date]):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[ResponseError]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                billing_entity_uuid: str

    Returns:
        Response[ResponseError]
    """
    # Extract request parameters from generated function
    kwargs = resolve_invoice_alliance_code._get_kwargs(billing_entity_uuid=billing_entity_uuid)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    import json
    from http import HTTPStatus
    from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        try:
            body_json = json.loads(proxy_response.body)
        except json.JSONDecodeError:
            pass

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and ResponseError:
        parsed = ResponseError.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode('utf-8') if proxy_response.body else b'',
        headers=proxy_response.headers,
        parsed=parsed,
    )




def resolve_invoice_alliance_code_sync(
    *,
    client: StolonClient,
    billing_entity_uuid: str
) -> ResponseError | None:
    """Resolve the invoice alliance code definition that applies for the specified billing entity

    Args:
        billing_entity_uuid (str):
        date (Union[Unset, datetime.date]):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        ResponseError

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                billing_entity_uuid: str

    Returns:
        ResponseError | None
    """
    # Extract request parameters from generated function
    kwargs = resolve_invoice_alliance_code._get_kwargs(billing_entity_uuid=billing_entity_uuid)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body
    import json
    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return ResponseError.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None




def resolve_invoice_alliance_code_asyncio_detailed(
    *,
    client: StolonClient,
    billing_entity_uuid: str
) -> Response[ResponseError]:
    """Resolve the invoice alliance code definition that applies for the specified billing entity

    Args:
        billing_entity_uuid (str):
        date (Union[Unset, datetime.date]):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[ResponseError]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                billing_entity_uuid: str

    Returns:
        Response[ResponseError]
    """
    # Extract request parameters from generated function
    kwargs = resolve_invoice_alliance_code._get_kwargs(billing_entity_uuid=billing_entity_uuid)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    import json
    from http import HTTPStatus
    from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        try:
            body_json = json.loads(proxy_response.body)
        except json.JSONDecodeError:
            pass

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and ResponseError:
        parsed = ResponseError.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode('utf-8') if proxy_response.body else b'',
        headers=proxy_response.headers,
        parsed=parsed,
    )




def resolve_invoice_alliance_code_asyncio(
    *,
    client: StolonClient,
    billing_entity_uuid: str
) -> ResponseError | None:
    """Resolve the invoice alliance code definition that applies for the specified billing entity

    Args:
        billing_entity_uuid (str):
        date (Union[Unset, datetime.date]):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        ResponseError

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                billing_entity_uuid: str

    Returns:
        ResponseError | None
    """
    # Extract request parameters from generated function
    kwargs = resolve_invoice_alliance_code._get_kwargs(billing_entity_uuid=billing_entity_uuid)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body
    import json
    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return ResponseError.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None

