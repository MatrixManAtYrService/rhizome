"""
Proxied wrapper functions for billing-bookkeeper dev - plan_action_fee_code.

Auto-generated by stolon sync spec.
These wrappers route requests through the stolon server for automatic
token management, logging, and retry logic.
"""

import contextlib
import json
from http import HTTPStatus

from stolon.client import StolonClient
from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.api.plan_action_fee_code import (
    create_plan_action_fee_code,
    delete_plan_action_fee_code_by_uuid,
    get_plan_action_fee_code_by_uuid,
    get_plan_action_fee_codes,
    update_plan_action_fee_code,
)
from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.models.response_error import ResponseError
from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.types import Response


def get_plan_action_fee_code_by_uuid_sync_detailed(*, client: StolonClient, uuid: str) -> Response[ResponseError]:
    """Get plan action fee code mapping by UUID

    Args:
        uuid (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[ResponseError]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                uuid: str

    Returns:
        Response[ResponseError]
    """
    # Extract request parameters from generated function
    kwargs = get_plan_action_fee_code_by_uuid._get_kwargs(uuid=uuid)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        with contextlib.suppress(json.JSONDecodeError):
            body_json = json.loads(proxy_response.body)

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and ResponseError:
        parsed = ResponseError.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode("utf-8") if proxy_response.body else b"",
        headers=proxy_response.headers,
        parsed=parsed,
    )


def get_plan_action_fee_code_by_uuid_sync(*, client: StolonClient, uuid: str) -> ResponseError | None:
    """Get plan action fee code mapping by UUID

    Args:
        uuid (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        ResponseError

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                uuid: str

    Returns:
        ResponseError | None
    """
    # Extract request parameters from generated function
    kwargs = get_plan_action_fee_code_by_uuid._get_kwargs(uuid=uuid)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body

    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return ResponseError.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None


def get_plan_action_fee_code_by_uuid_asyncio_detailed(*, client: StolonClient, uuid: str) -> Response[ResponseError]:
    """Get plan action fee code mapping by UUID

    Args:
        uuid (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[ResponseError]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                uuid: str

    Returns:
        Response[ResponseError]
    """
    # Extract request parameters from generated function
    kwargs = get_plan_action_fee_code_by_uuid._get_kwargs(uuid=uuid)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        with contextlib.suppress(json.JSONDecodeError):
            body_json = json.loads(proxy_response.body)

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and ResponseError:
        parsed = ResponseError.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode("utf-8") if proxy_response.body else b"",
        headers=proxy_response.headers,
        parsed=parsed,
    )


def get_plan_action_fee_code_by_uuid_asyncio(*, client: StolonClient, uuid: str) -> ResponseError | None:
    """Get plan action fee code mapping by UUID

    Args:
        uuid (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        ResponseError

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                uuid: str

    Returns:
        ResponseError | None
    """
    # Extract request parameters from generated function
    kwargs = get_plan_action_fee_code_by_uuid._get_kwargs(uuid=uuid)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body

    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return ResponseError.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None


def delete_plan_action_fee_code_by_uuid_sync_detailed(*, client: StolonClient, uuid: str) -> Response[ResponseError]:
    """Delete plan action fee code mapping

    Args:
        uuid (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[ResponseError]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                uuid: str

    Returns:
        Response[ResponseError]
    """
    # Extract request parameters from generated function
    kwargs = delete_plan_action_fee_code_by_uuid._get_kwargs(uuid=uuid)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        with contextlib.suppress(json.JSONDecodeError):
            body_json = json.loads(proxy_response.body)

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and ResponseError:
        parsed = ResponseError.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode("utf-8") if proxy_response.body else b"",
        headers=proxy_response.headers,
        parsed=parsed,
    )


def delete_plan_action_fee_code_by_uuid_sync(*, client: StolonClient, uuid: str) -> ResponseError | None:
    """Delete plan action fee code mapping

    Args:
        uuid (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        ResponseError

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                uuid: str

    Returns:
        ResponseError | None
    """
    # Extract request parameters from generated function
    kwargs = delete_plan_action_fee_code_by_uuid._get_kwargs(uuid=uuid)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body

    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return ResponseError.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None


def delete_plan_action_fee_code_by_uuid_asyncio_detailed(*, client: StolonClient, uuid: str) -> Response[ResponseError]:
    """Delete plan action fee code mapping

    Args:
        uuid (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[ResponseError]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                uuid: str

    Returns:
        Response[ResponseError]
    """
    # Extract request parameters from generated function
    kwargs = delete_plan_action_fee_code_by_uuid._get_kwargs(uuid=uuid)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        with contextlib.suppress(json.JSONDecodeError):
            body_json = json.loads(proxy_response.body)

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and ResponseError:
        parsed = ResponseError.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode("utf-8") if proxy_response.body else b"",
        headers=proxy_response.headers,
        parsed=parsed,
    )


def delete_plan_action_fee_code_by_uuid_asyncio(*, client: StolonClient, uuid: str) -> ResponseError | None:
    """Delete plan action fee code mapping

    Args:
        uuid (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        ResponseError

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                uuid: str

    Returns:
        ResponseError | None
    """
    # Extract request parameters from generated function
    kwargs = delete_plan_action_fee_code_by_uuid._get_kwargs(uuid=uuid)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body

    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return ResponseError.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None


def get_plan_action_fee_codes_sync_detailed(*, client: StolonClient) -> Response[ResponseError]:
    """Get plan action fee codes

    Args:
        date (datetime.date):
        plan_uuids (Union[Unset, list[str]]):
        fee_category (Union[Unset, str]):
        fee_code (Union[Unset, str]):
        plan_action_type (Union[Unset, str]):
        page_size (Union[Unset, int]):
        page_number (Union[Unset, int]):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[ResponseError]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests


    Returns:
        Response[ResponseError]
    """
    # Extract request parameters from generated function
    kwargs = get_plan_action_fee_codes._get_kwargs()

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        with contextlib.suppress(json.JSONDecodeError):
            body_json = json.loads(proxy_response.body)

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and ResponseError:
        parsed = ResponseError.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode("utf-8") if proxy_response.body else b"",
        headers=proxy_response.headers,
        parsed=parsed,
    )


def get_plan_action_fee_codes_sync(*, client: StolonClient) -> ResponseError | None:
    """Get plan action fee codes

    Args:
        date (datetime.date):
        plan_uuids (Union[Unset, list[str]]):
        fee_category (Union[Unset, str]):
        fee_code (Union[Unset, str]):
        plan_action_type (Union[Unset, str]):
        page_size (Union[Unset, int]):
        page_number (Union[Unset, int]):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        ResponseError

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests


    Returns:
        ResponseError | None
    """
    # Extract request parameters from generated function
    kwargs = get_plan_action_fee_codes._get_kwargs()

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body

    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return ResponseError.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None


def get_plan_action_fee_codes_asyncio_detailed(*, client: StolonClient) -> Response[ResponseError]:
    """Get plan action fee codes

    Args:
        date (datetime.date):
        plan_uuids (Union[Unset, list[str]]):
        fee_category (Union[Unset, str]):
        fee_code (Union[Unset, str]):
        plan_action_type (Union[Unset, str]):
        page_size (Union[Unset, int]):
        page_number (Union[Unset, int]):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[ResponseError]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests


    Returns:
        Response[ResponseError]
    """
    # Extract request parameters from generated function
    kwargs = get_plan_action_fee_codes._get_kwargs()

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        with contextlib.suppress(json.JSONDecodeError):
            body_json = json.loads(proxy_response.body)

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and ResponseError:
        parsed = ResponseError.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode("utf-8") if proxy_response.body else b"",
        headers=proxy_response.headers,
        parsed=parsed,
    )


def get_plan_action_fee_codes_asyncio(*, client: StolonClient) -> ResponseError | None:
    """Get plan action fee codes

    Args:
        date (datetime.date):
        plan_uuids (Union[Unset, list[str]]):
        fee_category (Union[Unset, str]):
        fee_code (Union[Unset, str]):
        plan_action_type (Union[Unset, str]):
        page_size (Union[Unset, int]):
        page_number (Union[Unset, int]):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        ResponseError

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests


    Returns:
        ResponseError | None
    """
    # Extract request parameters from generated function
    kwargs = get_plan_action_fee_codes._get_kwargs()

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body

    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return ResponseError.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None


def create_plan_action_fee_code_sync_detailed(*, client: StolonClient) -> Response[ResponseError]:
    """Create plan action fee code mapping

    Args:
        body (ApiPlanActionFeeCode): All plan action fee code records used by this plan pricing
            abstraction

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[ResponseError]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests


    Returns:
        Response[ResponseError]
    """
    # Extract request parameters from generated function
    kwargs = create_plan_action_fee_code._get_kwargs()

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        with contextlib.suppress(json.JSONDecodeError):
            body_json = json.loads(proxy_response.body)

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and ResponseError:
        parsed = ResponseError.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode("utf-8") if proxy_response.body else b"",
        headers=proxy_response.headers,
        parsed=parsed,
    )


def create_plan_action_fee_code_sync(*, client: StolonClient) -> ResponseError | None:
    """Create plan action fee code mapping

    Args:
        body (ApiPlanActionFeeCode): All plan action fee code records used by this plan pricing
            abstraction

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        ResponseError

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests


    Returns:
        ResponseError | None
    """
    # Extract request parameters from generated function
    kwargs = create_plan_action_fee_code._get_kwargs()

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body

    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return ResponseError.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None


def create_plan_action_fee_code_asyncio_detailed(*, client: StolonClient) -> Response[ResponseError]:
    """Create plan action fee code mapping

    Args:
        body (ApiPlanActionFeeCode): All plan action fee code records used by this plan pricing
            abstraction

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[ResponseError]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests


    Returns:
        Response[ResponseError]
    """
    # Extract request parameters from generated function
    kwargs = create_plan_action_fee_code._get_kwargs()

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        with contextlib.suppress(json.JSONDecodeError):
            body_json = json.loads(proxy_response.body)

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and ResponseError:
        parsed = ResponseError.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode("utf-8") if proxy_response.body else b"",
        headers=proxy_response.headers,
        parsed=parsed,
    )


def create_plan_action_fee_code_asyncio(*, client: StolonClient) -> ResponseError | None:
    """Create plan action fee code mapping

    Args:
        body (ApiPlanActionFeeCode): All plan action fee code records used by this plan pricing
            abstraction

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        ResponseError

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests


    Returns:
        ResponseError | None
    """
    # Extract request parameters from generated function
    kwargs = create_plan_action_fee_code._get_kwargs()

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body

    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return ResponseError.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None


def update_plan_action_fee_code_sync_detailed(*, client: StolonClient, uuid: str) -> Response[ResponseError]:
    """Update plan action fee code mapping

    Args:
        uuid (str):
        body (ApiPlanActionFeeCode): All plan action fee code records used by this plan pricing
            abstraction

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[ResponseError]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                uuid: str

    Returns:
        Response[ResponseError]
    """
    # Extract request parameters from generated function
    kwargs = update_plan_action_fee_code._get_kwargs(uuid=uuid)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        with contextlib.suppress(json.JSONDecodeError):
            body_json = json.loads(proxy_response.body)

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and ResponseError:
        parsed = ResponseError.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode("utf-8") if proxy_response.body else b"",
        headers=proxy_response.headers,
        parsed=parsed,
    )


def update_plan_action_fee_code_sync(*, client: StolonClient, uuid: str) -> ResponseError | None:
    """Update plan action fee code mapping

    Args:
        uuid (str):
        body (ApiPlanActionFeeCode): All plan action fee code records used by this plan pricing
            abstraction

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        ResponseError

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                uuid: str

    Returns:
        ResponseError | None
    """
    # Extract request parameters from generated function
    kwargs = update_plan_action_fee_code._get_kwargs(uuid=uuid)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body

    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return ResponseError.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None


def update_plan_action_fee_code_asyncio_detailed(*, client: StolonClient, uuid: str) -> Response[ResponseError]:
    """Update plan action fee code mapping

    Args:
        uuid (str):
        body (ApiPlanActionFeeCode): All plan action fee code records used by this plan pricing
            abstraction

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[ResponseError]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                uuid: str

    Returns:
        Response[ResponseError]
    """
    # Extract request parameters from generated function
    kwargs = update_plan_action_fee_code._get_kwargs(uuid=uuid)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    from stolon.generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        with contextlib.suppress(json.JSONDecodeError):
            body_json = json.loads(proxy_response.body)

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and ResponseError:
        parsed = ResponseError.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode("utf-8") if proxy_response.body else b"",
        headers=proxy_response.headers,
        parsed=parsed,
    )


def update_plan_action_fee_code_asyncio(*, client: StolonClient, uuid: str) -> ResponseError | None:
    """Update plan action fee code mapping

    Args:
        uuid (str):
        body (ApiPlanActionFeeCode): All plan action fee code records used by this plan pricing
            abstraction

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        ResponseError

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                uuid: str

    Returns:
        ResponseError | None
    """
    # Extract request parameters from generated function
    kwargs = update_plan_action_fee_code._get_kwargs(uuid=uuid)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body

    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return ResponseError.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None
