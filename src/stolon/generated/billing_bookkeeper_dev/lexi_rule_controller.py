"""
Proxied wrapper functions for billing-bookkeeper dev - lexi_rule_controller.

Auto-generated by stolon sync spec - do not edit directly.
These wrappers route requests through the stolon server for automatic
token management, logging, and retry logic.

The underlying OpenAPI client is in stolon.openapi_generated - DO NOT EDIT those files.
These wrapper files in stolon.generated can be customized if needed.
"""

import json
from http import HTTPStatus

from stolon.client import StolonClient
from stolon.openapi_generated.billing_bookkeeper_dev.open_api_definition_client.api.lexi_rule_controller import (
    create_activation_rule,
    create_conditional_rule,
    create_simple_rule,
    create_unit_rule,
    delete_rule,
    get_rule,
    get_rules_by_lexicon,
)
from stolon.openapi_generated.billing_bookkeeper_dev.open_api_definition_client.models.activation_rule import (
    ActivationRule,
)
from stolon.openapi_generated.billing_bookkeeper_dev.open_api_definition_client.models.all_rules import AllRules
from stolon.openapi_generated.billing_bookkeeper_dev.open_api_definition_client.models.base_rule import BaseRule
from stolon.openapi_generated.billing_bookkeeper_dev.open_api_definition_client.models.conditional_rule import (
    ConditionalRule,
)
from stolon.openapi_generated.billing_bookkeeper_dev.open_api_definition_client.models.simple_rule import SimpleRule
from stolon.openapi_generated.billing_bookkeeper_dev.open_api_definition_client.models.unit_rule import UnitRule
from stolon.openapi_generated.billing_bookkeeper_dev.open_api_definition_client.types import Response


def delete_rule_sync_detailed(*, client: StolonClient, uuid: str) -> Response[int]:
    """Args:
        uuid (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[int]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                uuid: str

    Returns:
        Response[int]
    """
    # Extract request parameters from generated function
    kwargs = delete_rule._get_kwargs(uuid=uuid)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    from stolon.openapi_generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        try:
            body_json = json.loads(proxy_response.body)
        except json.JSONDecodeError:
            pass

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and None:
        parsed = None.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode("utf-8") if proxy_response.body else b"",
        headers=proxy_response.headers,
        parsed=parsed,
    )


def delete_rule_sync(*, client: StolonClient, uuid: str) -> int | None:
    """Args:
        uuid (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        int

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                uuid: str

    Returns:
        int | None
    """
    # Extract request parameters from generated function
    kwargs = delete_rule._get_kwargs(uuid=uuid)

    # Proxy request through stolon server
    client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # No response model, return None
    return None


def delete_rule_asyncio_detailed(*, client: StolonClient, uuid: str) -> Response[int]:
    """Args:
        uuid (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[int]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                uuid: str

    Returns:
        Response[int]
    """
    # Extract request parameters from generated function
    kwargs = delete_rule._get_kwargs(uuid=uuid)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    from stolon.openapi_generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        try:
            body_json = json.loads(proxy_response.body)
        except json.JSONDecodeError:
            pass

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and None:
        parsed = None.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode("utf-8") if proxy_response.body else b"",
        headers=proxy_response.headers,
        parsed=parsed,
    )


def delete_rule_asyncio(*, client: StolonClient, uuid: str) -> int | None:
    """Args:
        uuid (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        int

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                uuid: str

    Returns:
        int | None
    """
    # Extract request parameters from generated function
    kwargs = delete_rule._get_kwargs(uuid=uuid)

    # Proxy request through stolon server
    client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # No response model, return None
    return None


def get_rules_by_lexicon_sync_detailed(*, client: StolonClient, lexicon: str) -> Response[AllRules]:
    """Args:
        lexicon (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[AllRules]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                lexicon: str

    Returns:
        Response[AllRules]
    """
    # Extract request parameters from generated function
    kwargs = get_rules_by_lexicon._get_kwargs(lexicon=lexicon)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    from stolon.openapi_generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        try:
            body_json = json.loads(proxy_response.body)
        except json.JSONDecodeError:
            pass

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and AllRules:
        parsed = AllRules.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode("utf-8") if proxy_response.body else b"",
        headers=proxy_response.headers,
        parsed=parsed,
    )


def get_rules_by_lexicon_sync(*, client: StolonClient, lexicon: str) -> AllRules | None:
    """Args:
        lexicon (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        AllRules

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                lexicon: str

    Returns:
        AllRules | None
    """
    # Extract request parameters from generated function
    kwargs = get_rules_by_lexicon._get_kwargs(lexicon=lexicon)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body

    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return AllRules.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None


def get_rules_by_lexicon_asyncio_detailed(*, client: StolonClient, lexicon: str) -> Response[AllRules]:
    """Args:
        lexicon (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[AllRules]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                lexicon: str

    Returns:
        Response[AllRules]
    """
    # Extract request parameters from generated function
    kwargs = get_rules_by_lexicon._get_kwargs(lexicon=lexicon)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    from stolon.openapi_generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        try:
            body_json = json.loads(proxy_response.body)
        except json.JSONDecodeError:
            pass

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and AllRules:
        parsed = AllRules.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode("utf-8") if proxy_response.body else b"",
        headers=proxy_response.headers,
        parsed=parsed,
    )


def get_rules_by_lexicon_asyncio(*, client: StolonClient, lexicon: str) -> AllRules | None:
    """Args:
        lexicon (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        AllRules

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                lexicon: str

    Returns:
        AllRules | None
    """
    # Extract request parameters from generated function
    kwargs = get_rules_by_lexicon._get_kwargs(lexicon=lexicon)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body

    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return AllRules.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None


def get_rule_sync_detailed(*, client: StolonClient, uuid: str) -> Response[AllRules]:
    """Args:
        uuid (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[AllRules]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                uuid: str

    Returns:
        Response[AllRules]
    """
    # Extract request parameters from generated function
    kwargs = get_rule._get_kwargs(uuid=uuid)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    from stolon.openapi_generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        try:
            body_json = json.loads(proxy_response.body)
        except json.JSONDecodeError:
            pass

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and AllRules:
        parsed = AllRules.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode("utf-8") if proxy_response.body else b"",
        headers=proxy_response.headers,
        parsed=parsed,
    )


def get_rule_sync(*, client: StolonClient, uuid: str) -> AllRules | None:
    """Args:
        uuid (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        AllRules

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                uuid: str

    Returns:
        AllRules | None
    """
    # Extract request parameters from generated function
    kwargs = get_rule._get_kwargs(uuid=uuid)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body

    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return AllRules.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None


def get_rule_asyncio_detailed(*, client: StolonClient, uuid: str) -> Response[AllRules]:
    """Args:
        uuid (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[AllRules]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                uuid: str

    Returns:
        Response[AllRules]
    """
    # Extract request parameters from generated function
    kwargs = get_rule._get_kwargs(uuid=uuid)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    from stolon.openapi_generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        try:
            body_json = json.loads(proxy_response.body)
        except json.JSONDecodeError:
            pass

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and AllRules:
        parsed = AllRules.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode("utf-8") if proxy_response.body else b"",
        headers=proxy_response.headers,
        parsed=parsed,
    )


def get_rule_asyncio(*, client: StolonClient, uuid: str) -> AllRules | None:
    """Args:
        uuid (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        AllRules

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                uuid: str

    Returns:
        AllRules | None
    """
    # Extract request parameters from generated function
    kwargs = get_rule._get_kwargs(uuid=uuid)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body

    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return AllRules.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None


def create_simple_rule_sync_detailed(*, client: StolonClient, body: SimpleRule) -> Response[BaseRule]:
    """Args:
        body (SimpleRule):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[BaseRule]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                body: SimpleRule

    Returns:
        Response[BaseRule]
    """
    # Extract request parameters from generated function
    kwargs = create_simple_rule._get_kwargs(body=body)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    from stolon.openapi_generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        try:
            body_json = json.loads(proxy_response.body)
        except json.JSONDecodeError:
            pass

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and BaseRule:
        parsed = BaseRule.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode("utf-8") if proxy_response.body else b"",
        headers=proxy_response.headers,
        parsed=parsed,
    )


def create_simple_rule_sync(*, client: StolonClient, body: SimpleRule) -> BaseRule | None:
    """Args:
        body (SimpleRule):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        BaseRule

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                body: SimpleRule

    Returns:
        BaseRule | None
    """
    # Extract request parameters from generated function
    kwargs = create_simple_rule._get_kwargs(body=body)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body

    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return BaseRule.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None


def create_simple_rule_asyncio_detailed(*, client: StolonClient, body: SimpleRule) -> Response[BaseRule]:
    """Args:
        body (SimpleRule):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[BaseRule]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                body: SimpleRule

    Returns:
        Response[BaseRule]
    """
    # Extract request parameters from generated function
    kwargs = create_simple_rule._get_kwargs(body=body)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    from stolon.openapi_generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        try:
            body_json = json.loads(proxy_response.body)
        except json.JSONDecodeError:
            pass

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and BaseRule:
        parsed = BaseRule.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode("utf-8") if proxy_response.body else b"",
        headers=proxy_response.headers,
        parsed=parsed,
    )


def create_simple_rule_asyncio(*, client: StolonClient, body: SimpleRule) -> BaseRule | None:
    """Args:
        body (SimpleRule):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        BaseRule

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                body: SimpleRule

    Returns:
        BaseRule | None
    """
    # Extract request parameters from generated function
    kwargs = create_simple_rule._get_kwargs(body=body)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body

    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return BaseRule.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None


def create_activation_rule_sync_detailed(*, client: StolonClient, body: ActivationRule) -> Response[BaseRule]:
    """Args:
        body (ActivationRule):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[BaseRule]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                body: ActivationRule

    Returns:
        Response[BaseRule]
    """
    # Extract request parameters from generated function
    kwargs = create_activation_rule._get_kwargs(body=body)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    from stolon.openapi_generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        try:
            body_json = json.loads(proxy_response.body)
        except json.JSONDecodeError:
            pass

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and BaseRule:
        parsed = BaseRule.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode("utf-8") if proxy_response.body else b"",
        headers=proxy_response.headers,
        parsed=parsed,
    )


def create_activation_rule_sync(*, client: StolonClient, body: ActivationRule) -> BaseRule | None:
    """Args:
        body (ActivationRule):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        BaseRule

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                body: ActivationRule

    Returns:
        BaseRule | None
    """
    # Extract request parameters from generated function
    kwargs = create_activation_rule._get_kwargs(body=body)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body

    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return BaseRule.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None


def create_activation_rule_asyncio_detailed(*, client: StolonClient, body: ActivationRule) -> Response[BaseRule]:
    """Args:
        body (ActivationRule):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[BaseRule]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                body: ActivationRule

    Returns:
        Response[BaseRule]
    """
    # Extract request parameters from generated function
    kwargs = create_activation_rule._get_kwargs(body=body)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    from stolon.openapi_generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        try:
            body_json = json.loads(proxy_response.body)
        except json.JSONDecodeError:
            pass

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and BaseRule:
        parsed = BaseRule.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode("utf-8") if proxy_response.body else b"",
        headers=proxy_response.headers,
        parsed=parsed,
    )


def create_activation_rule_asyncio(*, client: StolonClient, body: ActivationRule) -> BaseRule | None:
    """Args:
        body (ActivationRule):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        BaseRule

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                body: ActivationRule

    Returns:
        BaseRule | None
    """
    # Extract request parameters from generated function
    kwargs = create_activation_rule._get_kwargs(body=body)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body

    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return BaseRule.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None


def create_unit_rule_sync_detailed(*, client: StolonClient, body: UnitRule) -> Response[BaseRule]:
    """Args:
        body (UnitRule):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[BaseRule]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                body: UnitRule

    Returns:
        Response[BaseRule]
    """
    # Extract request parameters from generated function
    kwargs = create_unit_rule._get_kwargs(body=body)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    from stolon.openapi_generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        try:
            body_json = json.loads(proxy_response.body)
        except json.JSONDecodeError:
            pass

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and BaseRule:
        parsed = BaseRule.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode("utf-8") if proxy_response.body else b"",
        headers=proxy_response.headers,
        parsed=parsed,
    )


def create_unit_rule_sync(*, client: StolonClient, body: UnitRule) -> BaseRule | None:
    """Args:
        body (UnitRule):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        BaseRule

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                body: UnitRule

    Returns:
        BaseRule | None
    """
    # Extract request parameters from generated function
    kwargs = create_unit_rule._get_kwargs(body=body)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body

    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return BaseRule.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None


def create_unit_rule_asyncio_detailed(*, client: StolonClient, body: UnitRule) -> Response[BaseRule]:
    """Args:
        body (UnitRule):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[BaseRule]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                body: UnitRule

    Returns:
        Response[BaseRule]
    """
    # Extract request parameters from generated function
    kwargs = create_unit_rule._get_kwargs(body=body)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    from stolon.openapi_generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        try:
            body_json = json.loads(proxy_response.body)
        except json.JSONDecodeError:
            pass

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and BaseRule:
        parsed = BaseRule.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode("utf-8") if proxy_response.body else b"",
        headers=proxy_response.headers,
        parsed=parsed,
    )


def create_unit_rule_asyncio(*, client: StolonClient, body: UnitRule) -> BaseRule | None:
    """Args:
        body (UnitRule):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        BaseRule

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                body: UnitRule

    Returns:
        BaseRule | None
    """
    # Extract request parameters from generated function
    kwargs = create_unit_rule._get_kwargs(body=body)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body

    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return BaseRule.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None


def create_conditional_rule_sync_detailed(*, client: StolonClient, body: ConditionalRule) -> Response[BaseRule]:
    """Args:
        body (ConditionalRule):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[BaseRule]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                body: ConditionalRule

    Returns:
        Response[BaseRule]
    """
    # Extract request parameters from generated function
    kwargs = create_conditional_rule._get_kwargs(body=body)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    from stolon.openapi_generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        try:
            body_json = json.loads(proxy_response.body)
        except json.JSONDecodeError:
            pass

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and BaseRule:
        parsed = BaseRule.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode("utf-8") if proxy_response.body else b"",
        headers=proxy_response.headers,
        parsed=parsed,
    )


def create_conditional_rule_sync(*, client: StolonClient, body: ConditionalRule) -> BaseRule | None:
    """Args:
        body (ConditionalRule):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        BaseRule

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                body: ConditionalRule

    Returns:
        BaseRule | None
    """
    # Extract request parameters from generated function
    kwargs = create_conditional_rule._get_kwargs(body=body)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body

    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return BaseRule.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None


def create_conditional_rule_asyncio_detailed(*, client: StolonClient, body: ConditionalRule) -> Response[BaseRule]:
    """Args:
        body (ConditionalRule):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[BaseRule]

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                body: ConditionalRule

    Returns:
        Response[BaseRule]
    """
    # Extract request parameters from generated function
    kwargs = create_conditional_rule._get_kwargs(body=body)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response into Response object (detailed variant)
    from stolon.openapi_generated.billing_bookkeeper_dev.open_api_definition_client.types import Response

    # Parse body if JSON
    body_json = None
    if proxy_response.body:
        try:
            body_json = json.loads(proxy_response.body)
        except json.JSONDecodeError:
            pass

    # Parse response using generated function's parser
    if body_json and proxy_response.status_code == 200 and BaseRule:
        parsed = BaseRule.from_dict(body_json)
    else:
        parsed = None

    return Response(
        status_code=HTTPStatus(proxy_response.status_code),
        content=proxy_response.body.encode("utf-8") if proxy_response.body else b"",
        headers=proxy_response.headers,
        parsed=parsed,
    )


def create_conditional_rule_asyncio(*, client: StolonClient, body: ConditionalRule) -> BaseRule | None:
    """Args:
        body (ConditionalRule):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        BaseRule

    This function wraps the generated OpenAPI client to proxy requests through
    the stolon server, enabling automatic token management and logging.

    Args:
        client: StolonClient instance for proxying requests
                body: ConditionalRule

    Returns:
        BaseRule | None
    """
    # Extract request parameters from generated function
    kwargs = create_conditional_rule._get_kwargs(body=body)

    # Proxy request through stolon server
    proxy_response = client.proxy_request(
        domain="dev1.dev.clover.com",
        method=kwargs["method"],
        path=kwargs["url"],
        environment_name="dev",
        json_body=kwargs.get("json"),
        params=kwargs.get("params"),
        timeout=30.0,
    )

    # Parse response body

    if proxy_response.body and proxy_response.status_code == 200:
        try:
            body_json = json.loads(proxy_response.body)
            return BaseRule.from_dict(body_json)
        except (json.JSONDecodeError, KeyError, TypeError):
            pass
    return None
